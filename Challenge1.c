#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* void checkIfStuck(int sensorTouched) {
	int freeToMoveCounter = 0;
	while(freeToMoveCounter < 20000) {
		if(sensorTouched == 1) {
			if(getTouchValue(S2) == 0) {
				motor[motorA] = 20;
				motor[motorB] = 20;
			} else {
			//if stuck do a 180(ish)
				motor[motorA] = 30;
				motor[motorB] = -30;
				sleep(300);
			}
		} else {
			if(getTouchValue(S1) == 0) {
				motor[motorA] = 20;
				motor[motorB] = 20;
			}else {
				motor[motorA] = 30;
				motor[motorB] = -30;
				sleep(300);
			}
		}
		freeToMoveCounter++;
	}
} */

task main()
{
	int highPowerMin = 50;
	int highPowerMax = 80;
	int lowPowerMin = 0;
	int lowPowerMax = 10;
	int minWalkTime = 10000;
	int maxWalkTime = 30000;
	int loops = 0;
	srand(nSysTime);
	while (true)
	{
		// Turn the LED red if the touch sensor is pressed
		if(getTouchValue(S1) == 1 || getTouchValue(S2) == 1) {
			sleep(150);
			if (getTouchValue(S1) == 1 && getTouchValue(S2) == 1)
			{
				playSound(soundBeepBeep);
				motor[motorA] = -(highPowerMax);
				motor[motorB] = -(highPowerMax);
				sleep(500);

				motor[motorA] = 0;
				motor[motorB] = 0;
				sleep(2000);

				int power = (random(highPowerMax-highPowerMin) + highPowerMin); // random(60 - 40) + 40 == 40 to 60
 				if(random(1) == 0){
 					motor[motorA] = power;
					motor[motorB] = -power;
				} else {
					motor[motorA] = -power;
					motor[motorB] = power;
				}
				sleep(250);
			}
			else if (getTouchValue(S1) == 1)
			{
				// If total number of bumps on both sensors over 2 within loops number of iterations, 
				// maybe we're stuck at a corner/wall and need to turn around. 
				if((getBumpedValue(S1) + getBumpedValue(S2)) > 2) {
					playSound(soundBeepBeep);
					motor[motorA] = -65;
					motor[motorB] = 65;
					sleep(500);
				} else {
					motor[motorA] = -(random(highPowerMax-highPowerMin) + highPowerMin);
					motor[motorB] = -(random(lowPowerMax-lowPowerMin) + lowPowerMin);

					sleep(random(500) + 250);
					// checkIfStuck(1);
				}
			}
			else if (getTouchValue(S2) == 1)
			{
				// If total number of bumps on both sensors over 2 within loops number of iterations, 
				// maybe we're stuck at a corner/wall and need to turn around. 
				if((getBumpedValue(S1) + getBumpedValue(S2)) > 2) {
					playSound(soundBeepBeep);
					motor[motorA] = 65;
					motor[motorB] = -65;
					sleep(500);
				} else {
					motor[motorA] = -(random(lowPowerMax-lowPowerMin) + lowPowerMin);
					motor[motorB] = -(random(highPowerMax-highPowerMin) + highPowerMin);
					sleep(random(500) + 250);
					// checkIfStuck(2);
				}
			}
		}
		else
		{
			motor[motorA] = random(highPowerMax-highPowerMin) + highPowerMin;
			motor[motorB] = random(highPowerMax-highPowerMin) + highPowerMin;
			int counter = random(maxWalkTime - minWalkTime)+ minWalkTime;
			while(counter > 0) {
				if(getTouchValue(S1) == 1 || getTouchValue(S2) == 1) {
					counter = 0;
				} else {
					counter--;
				}
			}
			// Keeps track of the number of times the program enters this branch of the loop
			// If it's (presumably) not stuck in a corner, reset this count and bumped values
			// after 5 loops.
			if(loops > 5) {
				loops = 0;
				resetBumpedValue(S1);
				resetBumpedValue(S2);
			// Or else increment the number of loops 
			} else {
				loops++;
			}
		}
	}
}